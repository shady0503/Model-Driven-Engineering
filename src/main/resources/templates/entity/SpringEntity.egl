[% import "../ForgeHelpers.eol"; %]
[%
    var tableName = entity.name;
    var className = tableName.toEntityName();
    var packageName = project.groupId + ".entity";
%]
package [%= packageName %];

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.ToString;
import lombok.EqualsAndHashCode;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.io.Serializable;
import java.util.*;
[% if (entity.columns.exists(c | c.type.name() == "DECIMAL")) { %]
import java.math.BigDecimal;
[% } %]
[% if (entity.columns.exists(c | c.type.name() == "DATE" or c.type.name() == "DATETIME")) { %]
import java.time.*;
[% } %]

/**
 * Entity class for [%= tableName %] table
 * Generated by CodeForge
 */
@Entity
@Table(name = "[%= tableName %]")
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@ToString(onlyExplicitlyIncluded = true)
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class [%= className %] implements Serializable {

    [% for (column in entity.columns) { %]
    [% if (column.primary) { %]
    @ToString.Include
    @EqualsAndHashCode.Include
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    [% } %]
    [% if (column.name == "created_at") { %]
    @CreatedDate
    [% } else if (column.name == "updated_at") { %]
    @LastModifiedDate
    [% } %]
    [% if (not column.nullable and not column.primary) { %]
    [% if (column.type.name() == "STRING") { %]
    @NotBlank(message = "[%= column.name %] is required")
    [% } else { %]
    @NotNull(message = "[%= column.name %] is required")
    [% } %]
    [% } %]
    [% if (column.type.name() == "STRING" and column.length > 0) { %]
    @Size(max = [%= column.length %], message = "[%= column.name %] cannot exceed [%= column.length %] characters")
    [% } %]
    @Column(name = "[%= column.name %]", nullable = [%= column.nullable %][% if (column.unique) { %], unique = true[% } %][% if (column.length > 0) { %], length = [%= column.length %][% } %])
    private [%= getJavaType(column.type.name()) %] [%= column.name.toCamelCase() %];
    
    [% } %]

    [% for (relation in entity.relations) { %]
    [%  
        var relType = relation.type.name();
        var targetEntity = relation.targetTable.toEntityName();
        var fieldName = relation.targetTable.toCamelCase(); 
        if (relType == "ONE_TO_MANY" or relType == "MANY_TO_MANY") {
            fieldName = fieldName.plural();
        }
        var joinColumn = relation.targetColumn;
        if (joinColumn == null or joinColumn == "") {
            joinColumn = relation.targetTable.toCamelCase() + "_id";
        }
    %]
    [% if (relType == "MANY_TO_ONE") { %]
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "[%= joinColumn %]")
    private [%= targetEntity %] [%= fieldName %];
    [% } else if (relType == "ONE_TO_MANY") { %]
    @OneToMany(mappedBy = "[%= tableName.toCamelCase() %]", cascade = CascadeType.ALL)
    @JsonIgnore
    private List<[%= targetEntity %]> [%= fieldName %];
    [% } %]
    [% } %]
}

