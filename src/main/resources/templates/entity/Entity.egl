[* This template generates a single JPA Entity class *]
[%
    var tableName = entity.tableName;
    if (tableName == "user") {
        tableName = "users";
    } else if (tableName == "character") {
        tableName = "characters";
    }
    
    // ========== OWNERSHIP VALIDATION (enforced in ETL, verified here) ==========
    for (relation in entity.relations) {
        var relType = relation.relationType;
        
        // MANY_TO_ONE must always be owner
        if (relType = "MANY_TO_ONE" and not relation.isOwner) {
            throw "VALIDATION ERROR: MANY_TO_ONE relation '" + relation.fieldName + "' in entity '" + entity.className + "' must be the owning side (isOwner=true).";
        }
        
        // ONE_TO_MANY must never be owner
        if (relType = "ONE_TO_MANY" and relation.isOwner) {
            throw "VALIDATION ERROR: ONE_TO_MANY relation '" + relation.fieldName + "' in entity '" + entity.className + "' must NOT be the owning side (isOwner=false).";
        }
        
        // ManyToMany owner must provide join table metadata
        if (relType = "MANY_TO_MANY" and relation.isOwner) {
            if (not relation.joinTableName.isDefined() or relation.joinTableName == "") {
                throw "VALIDATION ERROR: MANY_TO_MANY owner relation '" + relation.fieldName + "' in entity '" + entity.className + "' must define 'joinTableName'.";
            }
            if (not relation.joinColumnName.isDefined() or relation.joinColumnName == "") {
                throw "VALIDATION ERROR: MANY_TO_MANY owner relation '" + relation.fieldName + "' in entity '" + entity.className + "' must define 'joinColumnName'.";
            }
            if (not relation.inverseJoinColumnName.isDefined() or relation.inverseJoinColumnName == "") {
                throw "VALIDATION ERROR: MANY_TO_MANY owner relation '" + relation.fieldName + "' in entity '" + entity.className + "' must define 'inverseJoinColumnName'.";
            }
        }
        
        // ManyToMany non-owner must provide mappedBy
        if (relType = "MANY_TO_MANY" and not relation.isOwner) {
            if (not relation.mappedBy.isDefined() or relation.mappedBy == "") {
                throw "VALIDATION ERROR: MANY_TO_MANY inverse relation '" + relation.fieldName + "' in entity '" + entity.className + "' must define 'mappedBy'.";
            }
        }
        
        // OneToOne owner must provide joinColumnName
        if (relType = "ONE_TO_ONE" and relation.isOwner) {
            if (not relation.joinColumnName.isDefined() or relation.joinColumnName == "") {
                throw "VALIDATION ERROR: ONE_TO_ONE owner relation '" + relation.fieldName + "' in entity '" + entity.className + "' must define 'joinColumnName'.";
            }
        }
        
        // OneToOne non-owner must provide mappedBy
        if (relType = "ONE_TO_ONE" and not relation.isOwner) {
            if (not relation.mappedBy.isDefined() or relation.mappedBy == "") {
                throw "VALIDATION ERROR: ONE_TO_ONE inverse relation '" + relation.fieldName + "' in entity '" + entity.className + "' must define 'mappedBy'.";
            }
        }
    }
%]
package [%= entity.packageName %];

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.ToString;
import lombok.EqualsAndHashCode;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.io.Serializable;
[* Import Java types based on fields *]
[% var hasLocalDateTime = entity.fields.exists(f | f.javaType = "LocalDateTime"); %]
[% var hasLocalDate = entity.fields.exists(f | f.javaType = "LocalDate"); %]
[% var hasUUID = entity.fields.exists(f | f.javaType = "UUID"); %]
[% var hasBigDecimal = entity.fields.exists(f | f.javaType = "BigDecimal"); %]
[% if (hasLocalDateTime) { %]
import java.time.LocalDateTime;
[% } %]
[% if (hasLocalDate) { %]
import java.time.LocalDate;
[% } %]
[% if (hasUUID) { %]
import java.util.UUID;
[% } %]
[% if (hasBigDecimal) { %]
import java.math.BigDecimal;
[% } %]
[% if (entity.hasRelationships) { %]
import java.util.List;
import java.util.Set;
[% } %]

/**
 * Entity class for [%= tableName %] table
 * Generated by MDE Backend Generator
 */
@Entity
@Table(name = "[%= tableName %]")
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@ToString(onlyExplicitlyIncluded = true)
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class [%= entity.className %] implements Serializable {

    [* Generate Fields *]
    [% for (field in entity.fields) { %]
    [%
       // RULE: Skip raw FK fields (ending in Id/ID, but not the PK itself)
       // These are replaced by JPA relationship fields
       var fieldNameLower = field.fieldName.toLowerCase();
       if (not field.isPrimaryKey and (fieldNameLower.endsWith("id") or fieldNameLower.endsWith("_id"))) {
           // Check if there's a corresponding relation for this FK field
           var hasRelation = entity.relations.exists(r | 
               r.joinColumnName.isDefined() and 
               (r.joinColumnName = field.columnName or r.joinColumnName = field.fieldName)
           );
           
           if (hasRelation) {
               continue; // Skip this FK field - it's represented as a relationship
           }
       }
    %]
    [% if (field.isPrimaryKey) { %]
    @ToString.Include
    @EqualsAndHashCode.Include
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    [% } %]
    [% if (field.fieldName = "createdAt") { %]
    @CreatedDate
    [% } else if (field.fieldName = "updatedAt") { %]
    @LastModifiedDate
    [% } %]
    @Column(name = "[%= field.columnName %]", nullable = [%= field.isNullable %][% if (field.isUnique) { %], unique = true[% } %])
    private [%= field.javaType %] [%= field.fieldName %];
    
    [% } %]

    [* Generate Relationships *]
    [% for (relation in entity.relations) { %]
    [%  
        var relType = relation.relationType;
        var jpaAnnotation = "";
        if (relType = "ONE_TO_ONE") {
            jpaAnnotation = "OneToOne";
        } else if (relType = "ONE_TO_MANY") {
            jpaAnnotation = "OneToMany";
        } else if (relType = "MANY_TO_ONE") {
            jpaAnnotation = "ManyToOne";
        } else if (relType = "MANY_TO_MANY") {
            jpaAnnotation = "ManyToMany";
        } else {
            jpaAnnotation = relType;
        }
    %]
    [% if (not relation.isOwner) { %]
    @JsonIgnore
    [% } %]
    @[%= jpaAnnotation %](fetch = FetchType.LAZY[% if (not relation.isOwner and relation.mappedBy.isDefined() and relation.mappedBy != "") { %], mappedBy = "[%= relation.mappedBy %]"[% } %][% if (relation.cascadeType.isDefined() and relation.cascadeType != "") { %], cascade = CascadeType.[%= relation.cascadeType %][% } %])
    [% if (relation.isOwner and relType = "MANY_TO_MANY") { %]
    @JoinTable(
        name = "[%= relation.joinTableName %]",
        joinColumns = @JoinColumn(name = "[%= relation.joinColumnName %]"),
        inverseJoinColumns = @JoinColumn(name = "[%= relation.inverseJoinColumnName %]")
    )
    [% } else if (relation.isOwner and (relType = "MANY_TO_ONE" or relType = "ONE_TO_ONE") and relation.joinColumnName.isDefined() and relation.joinColumnName != "") { %]
    @JoinColumn(name = "[%= relation.joinColumnName %]")
    [% } %]

    [% if (relType = "MANY_TO_MANY") { %]
    private Set<[%= relation.targetEntity %]> [%= relation.fieldName %];
    [% } else if (relType = "ONE_TO_MANY") { %]
    private List<[%= relation.targetEntity %]> [%= relation.fieldName %];
    [% } else { %]
    private [%= relation.targetEntity %] [%= relation.fieldName %];
    [% } %]
    
    [% } %]
}
