/*****************************************************************************
 * ETL TRANSFORMATION: BackendConfig (PIM) → Context (PSM)
 * 
 * This transformation converts platform-independent backend configurations
 * into platform-specific context models optimized for Spring Boot code generation.
 *
 * Transformation Type: Exogenous, Out-Place, Uni-directional
 * Source Metamodel: MDE.ecore (BackendConfig)
 * Target Metamodel: Context.ecore (Context)
 * 
 * Author: Generated for Model-Driven Backend Generator
 *****************************************************************************/

// Pre-block: Declare source and target models
pre {
    var sourceModel = Source!BackendConfig.all.first();
    // Silent transformation
}

/*****************************************************************************
 * RULE 1: BackendConfig → ProjectContext
 * 
 * Transforms the main backend configuration into project-level context
 * that will drive project file generation (pom.xml, application.properties)
 *****************************************************************************/
rule BackendConfigToProjectContext 
    transform bc : Source!BackendConfig
    to pc : Target!ProjectContext {
    
    guard : bc.isDefined()
    
    pc.groupId = bc.project.groupId;
    pc.artifactId = bc.project.name;
    pc.version = "1.0.0";  // Default version if not specified
    pc.packageName = bc.project.groupId + "." + bc.project.name;
    
    // Map Java version (Project has javaVersion attribute directly)
    pc.javaVersion = bc.project.javaVersion.toString();
    
    // Map Spring Boot version (Project has springBootVersion attribute directly)
    pc.springBootVersion = bc.project.springBootVersion;
    
    // Map database type
    pc.databaseType = bc.database.type.toString();
    pc.databaseName = bc.database.name;
    
    // Generate dependencies (as DependencyContext objects)
    var dependencies = bc.generateDependencies();
    for (dep in dependencies) {
        var dc = new Target!DependencyContext;
        dc.groupId = dep.get("groupId");
        dc.artifactId = dep.get("artifactId");
        dc.version = dep.get("version");
        if (dep.isDefined() and dep.containsKey("scope")) {
            dc.scope = dep.get("scope");
        } else {
            dc.scope = "compile";
        }
        pc.dependencies.add(dc);
    }
    
    // Link to entity contexts (will be created by Table rules)
    pc.entities = bc.database.tables.equivalent();
    
    // ("Created ProjectContext: " + pc.artifactId).println();
}

/*****************************************************************************
 * RULE 2: Table → EntityContext
 * 
 * Transforms database tables into entity context objects
 * Each EntityContext represents a JPA entity class to be generated
 *****************************************************************************/
@lazy
rule TableToEntityContext 
    transform t : Source!Table
    to ec : Target!EntityContext {
    
    guard : t.isDefined() and t.columns.size() > 0
    
    // Basic naming
    ec.tableName = t.name;
    ec.className = t.name.toEntityName();  // users → User
    ec.packageName = Source!BackendConfig.all.first().project.groupId + "." 
                   + Source!BackendConfig.all.first().project.name + ".entity";
    
    // Transform columns to fields (exclude foreign key columns - they become relationships)
    ec.fields = t.columns.select(c | not c.relation.isDefined()).equivalent();
    
    // Transform foreign key columns to relations
    for (col in t.columns.select(c | c.relation.isDefined())) {
        var rel = col.equivalent("ColumnWithRelationToRelationContext");
        ec.relations.add(rel);
    }
    
    // Set hasRelationships flag
    ec.hasRelationships = ec.relations.size() > 0;
    
    // Find and set primary key
    var pkField = ec.fields.selectOne(f | f.isPrimaryKey);
    if (pkField.isDefined()) {
        ec.primaryKey = pkField;
    }
    
    // Note: repositoryName, serviceName, controllerName, apiPath 
    // are not in Context.ecore - they will be computed in templates
    
    // ("Created EntityContext: " + ec.className + " from table: " + t.name).println();
}

/*****************************************************************************
 * RULE 3: Column → FieldContext
 * 
 * Transforms table columns into field context objects
 * Each FieldContext represents a field in a JPA entity
 *****************************************************************************/
@lazy
rule ColumnToFieldContext 
    transform c : Source!Column
    to fc : Target!FieldContext {
    
    guard : c.isDefined()
    
    // Column metadata
    fc.columnName = c.name;
    fc.fieldName = c.name.toCamelCase();  // user_id → userId
    fc.javaType = mapToJavaType(c.type);  // DataType enum → Java type
    
    // Constraints
    fc.isNullable = c.nullable;
    fc.isUnique = c.unique;
    fc.isPrimaryKey = c.primary;  // Note: attribute is 'primary', not 'primaryKey'
    
    // Note: Annotations are handled in templates, not stored in Context model
    
    // ("Created FieldContext: " + fc.fieldName + " (" + fc.javaType + ")").println();
}

/*****************************************************************************
 * RULE 4: Column (with Relation) → RelationContext
 * 
 * Transforms foreign key columns into relation context objects
 * Each RelationContext represents a JPA relationship (@ManyToOne, @OneToMany, etc.)
 *****************************************************************************/
@lazy
rule ColumnWithRelationToRelationContext 
    transform c : Source!Column
    to rc : Target!RelationContext {
    
    guard : c.isDefined() and c.relation.isDefined()
    
    var r = c.relation;
    
    // Relationship type
    rc.relationType = r.type.toString();  // MANY_TO_ONE, ONE_TO_MANY, etc.
    
    // Target entity information - store table name, will be resolved in post-processing
    var targetTableName = getTargetTableName(r.targetTable);
    // Store table name temporarily - will be converted to className in post
    rc.targetEntity = targetTableName;
    
    // Join column is the column name itself
    rc.joinColumnName = c.name;
    
    // Mapped by (for bidirectional relationships)
    rc.mappedBy = r.determineMappedBy();
    
    // Cascade type (single string, not array)
    if (r.onDelete.isDefined()) {
        rc.cascadeType = r.onDelete.toString();
    } else if (r.cascadeTypes.isDefined() and r.cascadeTypes.size() > 0) {
        rc.cascadeType = r.cascadeTypes.first().toString();
    } else {
        rc.cascadeType = "ALL";
    }
    
    // Fetch type
    if (r.fetchType.isDefined()) {
        rc.fetchType = r.fetchType.toString();
    } else {
        rc.fetchType = "LAZY";
    }
    
    // Owner flag
    rc.isOwner = r.type.toString() = "MANY_TO_ONE";
    
    // Field name for the relationship
    // Use the column name to derive field name (e.g., "follower_id" → "follower")
    if (c.name.endsWith("_id")) {
        // Remove "_id" suffix and convert to camelCase
        // Example: "follower_id" → "follower", "user_id" → "user"
        rc.fieldName = c.name.substring(0, c.name.length() - 3).toCamelCase();
    } else {
        rc.fieldName = c.name.toCamelCase();
    }
    
    // ("Created RelationContext: " + rc.relationType + " " + rc.fieldName + " → " + rc.targetEntity).println();
}

/*****************************************************************************
 * RULE 4 (OLD): Relation → RelationContext
 * 
 * DEPRECATED - Kept for backward compatibility
 * Use ColumnWithRelationToRelationContext instead
 *****************************************************************************/
@lazy
rule RelationToRelationContext 
    transform r : Source!Relation
    to rc : Target!RelationContext {
    
    guard : r.isDefined() and r.targetTable.isDefined()
    
    // Relationship type
    rc.relationType = r.type.toString();  // MANY_TO_ONE, ONE_TO_MANY, etc.
    
    // Target entity information - store table name, will be resolved in post-processing
    var targetTableName = getTargetTableName(r.targetTable);
    // Store table name temporarily - will be converted to className in post
    rc.targetEntity = targetTableName;
    
    // Join column information
    if (r.foreignKeyColumn.isDefined()) {
        // Handle foreignKeyColumn as string or object
        if (r.foreignKeyColumn.isTypeOf(String)) {
            rc.joinColumnName = r.foreignKeyColumn;
        } else {
            rc.joinColumnName = r.foreignKeyColumn.name;
        }
    } else {
        rc.joinColumnName = r.determineJoinColumn();
    }
    
    // Mapped by (for bidirectional relationships)
    rc.mappedBy = r.determineMappedBy();
    
    // Cascade type (single string, not array)
    if (r.cascadeTypes.isDefined() and r.cascadeTypes.size() > 0) {
        rc.cascadeType = r.cascadeTypes.first().toString();
    } else {
        rc.cascadeType = "ALL";
    }
    
    // Fetch type
    if (r.fetchType.isDefined()) {
        rc.fetchType = r.fetchType.toString();
    } else {
        rc.fetchType = "LAZY";
    }
    
    // Owner flag
    rc.isOwner = r.type.toString() = "MANY_TO_ONE";
    
    // Field name for the relationship
    // If join column is defined (e.g., "follower_id"), use it to derive field name ("follower")
    // Otherwise, fall back to singular form of target table name
    if (rc.joinColumnName.isDefined() and rc.joinColumnName.endsWith("_id")) {
        // Remove "_id" suffix and convert to camelCase
        // Example: "follower_id" → "follower", "user_id" → "user"
        rc.fieldName = rc.joinColumnName.substring(0, rc.joinColumnName.length() - 3).toCamelCase();
    } else if (rc.joinColumnName.isDefined()) {
        rc.fieldName = rc.joinColumnName.toCamelCase();
    } else {
        rc.fieldName = targetTableName.singular();
    }
    
    // ("Created RelationContext: " + rc.relationType + " to " + rc.targetEntity).println();
}

/*****************************************************************************
 * POST-PROCESSING
 *****************************************************************************/
post {
    // Resolve table names to class names in all relationships
    resolveRelationshipTargets();
    
    // Create inverse relationships (e.g., if Posts has ManyToOne to Users, 
    // add OneToMany from Users to Posts)
    createInverseRelationships();
    
    // Add automatic audit timestamp fields to all entities
    addAuditFieldsToAllEntities();
    
    var projectContext = Target!ProjectContext.all.first();
    var entityCount = Target!EntityContext.all.size();
    var fieldCount = Target!FieldContext.all.size();
    var relationCount = Target!RelationContext.all.size();
    
    // "ETL Transformation Complete!".println();
    // "-------------------------------------".println();
    // ("Generated ProjectContext: " + projectContext.artifactId).println();
    // ("Generated " + entityCount + " EntityContext(s)").println();
    // ("Generated " + fieldCount + " FieldContext(s)").println();
    // ("Generated " + relationCount + " RelationContext(s)").println();
    // "-------------------------------------".println();
}

/*****************************************************************************
 * HELPER OPERATIONS
 * 
 * These operations provide reusable transformations for common tasks
 *****************************************************************************/

/**
 * Convert snake_case table name to PascalCase entity name
 * Example: blog_posts → BlogPost, user_profiles → UserProfile
 * Enhanced to handle edge cases like consecutive underscores
 */
operation String toEntityName() : String {
    var parts = self.split('_');
    var result = "";
    for (part in parts) {
        // Skip empty parts from consecutive underscores
        if (part.length() > 0) {
            result = result + part.firstToUpperCase();
        }
    }
    // If result is empty (e.g., input was "___"), return original
    if (result.length() == 0) {
        return self;
    }
    return result;
}

/**
 * Convert snake_case column name to camelCase field name
 * Example: user_id → userId, created_at → createdAt
 * Enhanced to handle edge cases like consecutive underscores
 */
operation String toCamelCase() : String {
    var parts = self.split('_');
    
    // Filter out empty parts from consecutive underscores
    var validParts = Sequence{};
    for (part in parts) {
        if (part.length() > 0) {
            validParts.add(part);
        }
    }
    
    // If no valid parts or only one part, return original
    if (validParts.size() == 0) {
        return self;
    }
    if (validParts.size() == 1) {
        return validParts.first();
    }
    
    // Build camelCase from valid parts
    var result = validParts.first();
    for (part in validParts.subList(1, validParts.size())) {
        result = result + part.firstToUpperCase();
    }
    return result;
}

/**
 * Convert first character to uppercase
 * Example: hello → Hello
 */
operation String firstToUpperCase() : String {
    if (self.length() == 0) {
        return self;
    }
    return self.substring(0, 1).toUpperCase() + self.substring(1, self.length());
}

/**
 * Map DataType enum to Java type
 */
operation mapToJavaType(dataType : Any) : String {
    var mapping = Map{
        "STRING" = "String",
        "INTEGER" = "Integer",
        "LONG" = "Long",
        "UUID" = "UUID",
        "BOOLEAN" = "Boolean",
        "DATE" = "LocalDate",
        "DATETIME" = "LocalDateTime",
        "TIMESTAMP" = "LocalDateTime",
        "TEXT" = "String",
        "DOUBLE" = "Double",
        "FLOAT" = "Float",
        "DECIMAL" = "BigDecimal"
    };
    var typeName = dataType.toString();  // Get enum literal as string
    var result = mapping.get(typeName);
    if (result.isDefined()) {
        return result;
    } else {
        return "String";  // Default to String if unknown
    }
}

/**
 * Map Database Type enum to string
 */
operation mapToDatabaseTypeString(dbType : Any) : String {
    return dbType.toString();
}

/**
 * Generate project dependencies based on configuration
 */
operation Source!BackendConfig generateDependencies() : Sequence {
    var dependencies = Sequence{};
    
    // Core Spring Boot dependencies
    dependencies.add(Map{
        "groupId" = "org.springframework.boot",
        "artifactId" = "spring-boot-starter-web",
        "version" = ""
    });
    
    dependencies.add(Map{
        "groupId" = "org.springframework.boot",
        "artifactId" = "spring-boot-starter-data-jpa",
        "version" = ""
    });
    
    // Database driver based on database type
    var dbDriver = getDatabaseDriver(self.database.type);
    dependencies.add(dbDriver);
    
    // Lombok
    dependencies.add(Map{
        "groupId" = "org.projectlombok",
        "artifactId" = "lombok",
        "version" = ""
    });
    
    return dependencies;
}

/**
 * Get database driver dependency based on database type
 */
operation getDatabaseDriver(dbType : Any) : Map {
    var typeName = dbType.toString();
    var drivers = Map{
        "POSTGRESQL" = Map{
            "groupId" = "org.postgresql",
            "artifactId" = "postgresql",
            "version" = ""
        },
        "MYSQL" = Map{
            "groupId" = "com.mysql",
            "artifactId" = "mysql-connector-j",
            "version" = ""
        },
        "H2" = Map{
            "groupId" = "com.h2database",
            "artifactId" = "h2",
            "version" = ""
        }
    };
    return drivers.get(typeName);
}

/**
 * Determine join column name from relation
 */
operation Source!Relation determineJoinColumn() : String {
    if (self.foreignKeyColumn.isDefined()) {
        // Handle foreignKeyColumn as string or object
        if (self.foreignKeyColumn.isTypeOf(String)) {
            return self.foreignKeyColumn;
        }
        return self.foreignKeyColumn.name;
    }
    // Get the target table name
    var targetTableName = getTargetTableName(self.targetTable);
    // Default: targetTable_id
    return targetTableName.singular() + "_id";
}

/**
 * Helper to get table name from targetTable (which might be a string or Table object)
 */
operation getTargetTableName(targetTable : Any) : String {
    if (targetTable.isTypeOf(String)) {
        return targetTable;
    }
    return targetTable.name;
}

/**
 * Resolve table names to class names in relationship targets
 * This must run AFTER all entities are created but BEFORE inverse relationships
 */
operation resolveRelationshipTargets() {
    // "Resolving relationship target entities...".println();
    
    var allEntities = Target!EntityContext.all;
    
    // For each entity
    for (entity in allEntities) {
        // For each relation in the entity
        for (relation in entity.relations) {
            // relation.targetEntity currently contains table name (e.g., "categories")
            // We need to convert it to class name (e.g., "Categories")
            var targetTableName = relation.targetEntity;
            var targetEntity = allEntities.selectOne(e | e.tableName = targetTableName);
            
            if (targetEntity.isDefined()) {
                // Update to class name
                relation.targetEntity = targetEntity.className;
    // ("  Resolved: " + entity.className + "." + relation.fieldName + " → " + targetEntity.className).println();
            } else {
    // ("  WARNING: Could not find target entity for table: " + targetTableName).println();
            }
        }
    }
}

/**
 * Create inverse relationships for bidirectional JPA mappings
 * For each MANY_TO_ONE relationship, create the corresponding ONE_TO_MANY on the parent entity
 */
operation createInverseRelationships() {
    // "Creating inverse relationships...".println();
    
    // Get all entities
    var allEntities = Target!EntityContext.all;
    
    // For each entity, look at its MANY_TO_ONE relationships
    for (entity in allEntities) {
        for (relation in entity.relations.select(r | r.relationType = "MANY_TO_ONE")) {
            // Find the target entity
            var targetEntity = allEntities.selectOne(e | e.className = relation.targetEntity);
            
            if (targetEntity.isDefined()) {
                // Check if inverse relationship already exists
                var existingInverse = targetEntity.relations.selectOne(r | 
                    r.relationType = "ONE_TO_MANY" and 
                    r.targetEntity = entity.className and
                    r.mappedBy = relation.fieldName
                );
                
                // Only create if it doesn't exist
                if (not existingInverse.isDefined()) {
                    // Create inverse ONE_TO_MANY relationship
                    var inverseRelation = new Target!RelationContext;
                    inverseRelation.relationType = "ONE_TO_MANY";
                    inverseRelation.targetEntity = entity.className;
                    
                    // Generate unique field name to avoid collisions
                    // Strategy: Use plural form of source table + source field name for uniqueness
                    // Example: for UserFollows.follower → Users, create "followerUserFollowsList"
                    //          for UserFollows.following → Users, create "followingUserFollowsList"
                    // This ensures uniqueness even when multiple FKs point to same table
                    var baseFieldName = entity.tableName.toCamelCase();
                    var uniqueFieldName = relation.fieldName + baseFieldName.firstToUpperCase() + "List";
                    
                    // Additional check: ensure this name doesn't already exist in target entity
                    var counter = 1;
                    var finalFieldName = uniqueFieldName;
                    while (targetEntity.relations.exists(r | r.fieldName = finalFieldName) or 
                           targetEntity.fields.exists(f | f.fieldName = finalFieldName)) {
                        finalFieldName = uniqueFieldName + counter.toString();
                        counter = counter + 1;
                    }
                    
                    inverseRelation.fieldName = finalFieldName;
                    
                    inverseRelation.mappedBy = relation.fieldName; // field name in the owning side
                    inverseRelation.cascadeType = "ALL";
                    inverseRelation.fetchType = "LAZY";
                    inverseRelation.isOwner = false;
                    
                    // Add to target entity
                    targetEntity.relations.add(inverseRelation);
                    
                    // Update hasRelationships flag
                    targetEntity.hasRelationships = true;
                    
    // ("  Created inverse: " + targetEntity.className + ".@OneToMany(" + inverseRelation.fieldName + ") → " + entity.className).println();
                }
            }
        }
    }
}

/**
 * Add automatic audit timestamp fields (createdAt, updatedAt) to all entities
 * These fields are managed by JPA auditing and don't need to be in the YAML
 */
operation addAuditFieldsToAllEntities() {
    // "Adding automatic audit fields to all entities...".println();
    
    var allEntities = Target!EntityContext.all;
    
    for (entity in allEntities) {
        // Check if createdAt already exists
        var hasCreatedAt = entity.fields.exists(f | f.fieldName = "createdAt");
        
        if (not hasCreatedAt) {
            // Create createdAt field
            var createdAtField = new Target!FieldContext;
            createdAtField.columnName = "created_at";
            createdAtField.fieldName = "createdAt";
            createdAtField.javaType = "LocalDateTime";
            createdAtField.isNullable = false;
            createdAtField.isUnique = false;
            createdAtField.isPrimaryKey = false;
            
            entity.fields.add(createdAtField);
    // ("  Added createdAt to " + entity.className).println();
        }
        
        // Check if updatedAt already exists
        var hasUpdatedAt = entity.fields.exists(f | f.fieldName = "updatedAt");
        
        if (not hasUpdatedAt) {
            // Create updatedAt field
            var updatedAtField = new Target!FieldContext;
            updatedAtField.columnName = "updated_at";
            updatedAtField.fieldName = "updatedAt";
            updatedAtField.javaType = "LocalDateTime";
            updatedAtField.isNullable = false;
            updatedAtField.isUnique = false;
            updatedAtField.isPrimaryKey = false;
            
            entity.fields.add(updatedAtField);
    // ("  Added updatedAt to " + entity.className).println();
        }
    }
}

/**
 * Find EntityContext in target model by table name
 */
operation findEntityByTableName(tableName : String) : Target!EntityContext {
    // Look through all created EntityContext objects in the target model
    return Target!EntityContext.all.selectOne(e | e.tableName = tableName);
}

/**
 * Determine mapped by for bidirectional relations
 */
operation Source!Relation determineMappedBy() : String {
    if (self.type.toString() = "ONE_TO_MANY") {
        // For ONE_TO_MANY, mappedBy should be the field name in the target entity
        var targetTableName = getTargetTableName(self.targetTable);
        return targetTableName.singular();
    }
    return "";
}

/**
 * Get singular form of a word (enhanced implementation with edge cases)
 */
operation String singular() : String {
    // Handle empty or single-character strings
    if (self.length() <= 1) {
        return self;
    }
    
    // Common irregular plurals
    if (self = "children") return "child";
    if (self = "people") return "person";
    if (self = "men") return "man";
    if (self = "women") return "woman";
    if (self = "feet") return "foot";
    if (self = "teeth") return "tooth";
    if (self = "geese") return "goose";
    if (self = "mice") return "mouse";
    
    // Words ending in 'ies' (e.g., categories -> category)
    if (self.length() > 3 and self.endsWith("ies")) {
        return self.substring(0, self.length() - 3) + "y";
    }
    
    // Words ending in 'ses' (e.g., classes -> class, addresses -> address)
    if (self.length() > 3 and self.endsWith("ses")) {
        return self.substring(0, self.length() - 2);
    }
    
    // Words ending in 'xes' (e.g., boxes -> box)
    if (self.length() > 3 and self.endsWith("xes")) {
        return self.substring(0, self.length() - 2);
    }
    
    // Words ending in 'ches' or 'shes' (e.g., branches -> branch, dishes -> dish)
    if (self.length() > 4 and (self.endsWith("ches") or self.endsWith("shes"))) {
        return self.substring(0, self.length() - 2);
    }
    
    // Words ending in 'oes' (e.g., heroes -> hero, tomatoes -> tomato)
    if (self.length() > 3 and self.endsWith("oes")) {
        return self.substring(0, self.length() - 2);
    }
    
    // Regular plural: just remove 's' if not ending in 'ss', 'us', 'is'
    if (self.endsWith("s") and not self.endsWith("ss") and not self.endsWith("us") and not self.endsWith("is")) {
        return self.substring(0, self.length() - 1);
    }
    
    // If none of the above, return as-is (likely already singular or special case)
    return self;
}
