# MDE Backend Generator - Architecture Documentation

## Overview

The MDE Backend Generator is a Model-Driven Engineering (MDE) tool that generates Spring Boot backend applications from YAML model files using the Eclipse Epsilon transformation stack.

---

## Architecture Diagram

```
┌─────────────┐
│  YAML File  │  Input (e.g., healthcare-system.yaml)
└──────┬──────┘
       │ T2M (Text-to-Model)
       │ via Flexmi
       ▼
┌───────────────┐
│ BackendConfig │  Ecore Model (conforms to MDE.ecore metamodel)
│   (M1 Layer)  │
└───────┬───────┘
        │ M2M (Model-to-Model)
        │ via ETL
        ▼
┌───────────────┐
│    Context    │  Enriched Code Generation Model
│   (M1 Layer)  │  (conforms to Context.ecore metamodel)
└───────┬───────┘
        │ M2T (Model-to-Text)
        │ via EGL
        ▼
┌───────────────┐
│  Spring Boot  │  Generated Java Code
│   Application │  (Controller, Service, Repository, Entity, etc.)
└───────────────┘
```

---

## Project Structure

```
src/
├── main/
│   ├── java/com/mde/
│   │   ├── cli/                    # Command-Line Interface
│   │   ├── generator/              # Core Generation Pipeline
│   │   ├── loader/                 # Model Loading (Flexmi)
│   │   ├── validation/             # Model Validation Rules
│   │   └── ModelDrivenEngineering/ # EMF Generated Code (MDE.ecore)
│   └── resources/
│       ├── etl/                    # ETL Transformation Scripts
│       └── templates/              # EGL Code Generation Templates
└── test/
    └── java/com/mde/               # Unit and Integration Tests
```

---

## Module Documentation

### 1. CLI Module (`com.mde.cli`)

**Purpose**: Command-line interface for the MDE generator.

#### Key Classes:

- **`MdeGenCli`**: Main entry point, root command
  - Configures Picocli command-line parser
  - Sets up color scheme and exception handling
  - Delegates to subcommands (generate, validate, help)

- **`GenerateCommand`**: Subcommand to generate Spring Boot projects
  - Parses YAML input file
  - Invokes code generation pipeline
  - Handles output directory and overwrite logic
  - Supports `--clean` flag to delete existing output

- **`ValidateCommand`**: Subcommand to validate YAML models
  - Runs validation rules without generating code
  - Supports `--strict` mode for enhanced validation
  - Reports validation errors with line numbers

- **`ColorOutput`**: ANSI color utility for console output
  - Success (green), error (red), warning (yellow), info (cyan)
  - Respects `NO_COLOR` environment variable
  - Supports `--no-color` flag

- **`ConsoleSymbols`**: Unicode/ASCII symbol adapter
  - Uses Unicode (✓ ✗ ⚠ ℹ) on modern terminals
  - Falls back to ASCII ([OK] [X] ! i) on Windows
  - Detects Windows Terminal for Unicode support

- **`CliExceptionHandler`**: Custom exception handler
  - Provides user-friendly error messages
  - Suggests fixes for common issues
  - Handles file not found, I/O, and validation errors

- **`ExitCode`**: Standard exit codes
  - `SUCCESS = 0`
  - `FILE_ERROR = 1`
  - `VALIDATION_ERROR = 2`
  - `GENERATION_ERROR = 3`
  - `IO_ERROR = 4`
  - `USAGE_ERROR = 64`
  - `INTERNAL_ERROR = 70`

---

### 2. Generator Module (`com.mde.generator`)

**Purpose**: Core code generation pipeline orchestration.

#### Key Classes:

- **`CodeGenerator`**: Main orchestrator for 3-phase pipeline
  - **Phase 1**: Parse YAML → BackendConfig (T2M via Flexmi)
  - **Phase 2**: Transform BackendConfig → Context (M2M via ETL)
  - **Phase 3**: Generate code from Context (M2T via EGL)
  - Manages temporary directories for intermediate models
  - Provides colored progress output

- **`Main`**: Legacy standalone entry point (deprecated)
  - Original main class before CLI was added
  - Now superseded by `MdeGenCli`

#### Submodules:

- **`egl/EGLTemplateEngine`**: Epsilon Generation Language (EGL) engine
  - M2T transformation: Context model → Java code
  - Loads `.egl` templates from `resources/templates/`
  - Generates: Entity, Repository, Service, Controller, Application, pom.xml, etc.
  - Uses EglTemplateFactory with EMF models

- **`etl/ETLTransformationEngine`**: Epsilon Transformation Language (ETL) engine
  - M2M transformation: BackendConfig → Context
  - Executes `BackendConfigToContext.etl` script
  - Enriches model with Java types, JPA annotations, package names
  - Calculates bidirectional relationships and cascade types

- **`Context/`**: EMF generated code for Context metamodel
  - `ProjectContext`: Project-level metadata (name, groupId, dependencies)
  - `EntityContext`: JPA entity metadata (table name, fields, relationships)
  - `FieldContext`: Entity field metadata (type, annotations, getters/setters)
  - `RelationContext`: Relationship metadata (type, cascade, mappedBy)
  - `DependencyContext`: Maven dependency metadata (groupId, artifactId, version)
  - Auto-generated by Eclipse EMF from `model/Context.ecore`

---

### 3. Loader Module (`com.mde.loader`)

**Purpose**: Load and parse YAML models using Flexmi.

#### Key Classes:

- **`FlexmiModelLoader`**: Flexmi (flexible XML/YAML) parser
  - Parses YAML files into BackendConfig EMF models
  - Registers MDE.ecore metamodel
  - Handles file not found and parse errors
  - Uses `FlexmiResourceFactory` from Epsilon

- **`FlexmiModelLoaderWithValidation`**: Loader with validation
  - Extends `FlexmiModelLoader`
  - Runs `ModelValidationEngine` after parsing
  - Supports strict mode for enhanced validation
  - Returns `ValidationResult` with errors/warnings

- **`ModelPackageRegistrar`**: Ecore package registration utility
  - Registers `ModelDrivenPackage` globally
  - Registers Flexmi resource factory for `.yaml` and `.flexmi` files
  - Ensures metamodel is available to Epsilon engines

- **`LoadException`**: Exception for model loading errors
  - Wraps file not found, parse errors, validation errors
  - Provides clear error messages for debugging

---

### 4. Validation Module (`com.mde.validation`)

**Purpose**: Validate YAML models against business rules.

#### Key Interfaces:

- **`ModelValidator`**: Interface for all validators
  - `validate(BackendConfig config): ValidationResult`
  - Implementations check specific rules

#### Validators:

- **`PrimaryKeyValidator`**: Ensures every table has a primary key
  - Error if table has no `id` column
  - Checks `primaryKey: true` attribute

- **`ForeignKeyTargetTableValidator`**: Validates FK target tables exist
  - Error if relation references non-existent table
  - Checks `targetTable` attribute

- **`ForeignKeyTargetColumnValidator`**: Validates FK target columns exist
  - Error if relation references non-existent column
  - Checks `targetColumn` attribute

- **`ForeignKeyTypeCompatibilityValidator`**: Validates FK type compatibility
  - Error if FK column type != target column type
  - e.g., INT cannot reference VARCHAR

- **`UniqueTableNamesValidator`**: Ensures table names are unique
  - Error if duplicate table names found
  - Checks database-wide uniqueness

- **`UniqueColumnNamesValidator`**: Ensures column names unique per table
  - Error if duplicate column names in same table
  - Checks table-level uniqueness

- **`JavaReservedKeywordValidator`**: Prevents Java keywords as identifiers
  - Error if table/column name is `class`, `public`, `static`, etc.
  - Checks against Java reserved word list

- **`SqlReservedKeywordValidator`**: Prevents SQL keywords as identifiers
  - Warning if table/column name is `SELECT`, `WHERE`, `TABLE`, etc.
  - Allows but warns (can be escaped with backticks)

- **`ApiRouteEntityValidator`**: Validates API route references
  - Error if route's `entity` doesn't exist
  - Checks API route definitions

#### Validation Engine:

- **`ModelValidationEngine`**: Orchestrates all validators
  - Runs all validators in sequence
  - Collects errors and warnings
  - Returns combined `ValidationResult`
  - Supports strict mode (warnings become errors)

- **`ValidationResult`**: Holds validation results
  - `List<String> errors`: Critical errors (must fix)
  - `List<String> warnings`: Non-critical warnings (should fix)
  - `isValid()`: Returns true if no errors
  - `hasWarnings()`: Returns true if has warnings

---

### 5. ModelDrivenEngineering Module

**Purpose**: EMF generated code from MDE.ecore metamodel.

This module is **auto-generated** by Eclipse EMF and should **not be manually edited**.

#### Metamodel Classes (Interfaces):

- **`BackendConfig`**: Root container
  - `project: Project`
  - `database: Database`
  - `api: Api [0..1]`

- **`Project`**: Project metadata
  - `name: String`
  - `groupId: String`
  - `version: String`
  - `description: String`
  - `language: Language` (enum: JAVA)
  - `framework: Framework` (enum: SPRING_BOOT)

- **`Database`**: Database schema
  - `name: String`
  - `type: DatabaseType` (enum: MYSQL, POSTGRESQL)
  - `tables: List<Table>`

- **`Table`**: Database table
  - `name: String`
  - `columns: List<Column>`

- **`Column`**: Table column
  - `name: String`
  - `type: DataType` (enum: INT, VARCHAR, DATETIME, etc.)
  - `length: int`
  - `nullable: boolean`
  - `unique: boolean`
  - `primaryKey: boolean`
  - `autoIncrement: boolean`
  - `defaultValue: String`
  - `relation: Relation [0..1]`

- **`Relation`**: Foreign key relationship
  - `type: RelationType` (enum: ONE_TO_ONE, ONE_TO_MANY, MANY_TO_ONE, MANY_TO_MANY)
  - `targetTable: String`
  - `targetColumn: String`
  - `cascade: CascadeType` (enum: ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH)

- **`Api`**: API configuration (optional)
  - `basePath: String`
  - `routes: List<Route>`

- **`Route`**: API route
  - `path: String`
  - `method: HttpMethod` (enum: GET, POST, PUT, DELETE, PATCH)
  - `entity: String`

#### Enums:

- **`Language`**: JAVA
- **`Framework`**: SPRING_BOOT
- **`DatabaseType`**: MYSQL, POSTGRESQL, H2
- **`DataType`**: INT, LONG, DOUBLE, FLOAT, BOOLEAN, VARCHAR, TEXT, DATETIME, DATE, TIME, TIMESTAMP
- **`RelationType`**: ONE_TO_ONE, ONE_TO_MANY, MANY_TO_ONE, MANY_TO_MANY
- **`CascadeType`**: ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH, NONE
- **`HttpMethod`**: GET, POST, PUT, DELETE, PATCH

#### Implementation Classes (`impl/` package):

- `BackendConfigImpl`
- `ProjectImpl`
- `DatabaseImpl`
- `TableImpl`
- `ColumnImpl`
- `RelationImpl`
- `ApiImpl`
- `RouteImpl`
- `ModelDrivenFactoryImpl`: Factory for creating instances
- `ModelDrivenPackageImpl`: Package descriptor and metadata

#### Utility Classes (`util/` package):

- `ModelDrivenAdapterFactory`: EMF adapter factory
- `ModelDrivenSwitch`: EMF switch for type-safe dispatching

---

## Transformation Pipeline

### Phase 1: Text-to-Model (T2M) - Flexmi

**Tool**: Eclipse Epsilon Flexmi  
**Input**: YAML file (e.g., `healthcare-system.yaml`)  
**Output**: `BackendConfig` EMF model  
**Responsibility**: `FlexmiModelLoader`

Flexmi is a flexible model loader that supports YAML, XML, and JSON formats. It parses the input file and creates an EMF model conforming to the `MDE.ecore` metamodel.

**Example YAML**:
```yaml
project:
  name: HealthcareAPI
  groupId: com.healthcare.system
  version: 1.0.0

database:
  name: healthcare_db
  type: mysql
  tables:
    - name: patients
      columns:
        - name: id
          type: int
          primaryKey: true
          autoIncrement: true
        - name: name
          type: varchar
          length: 255
```

### Phase 2: Model-to-Model (M2M) - ETL

**Tool**: Eclipse Epsilon Transformation Language (ETL)  
**Input**: `BackendConfig` model  
**Output**: `Context` model  
**Script**: `src/main/resources/etl/BackendConfigToContext.etl`  
**Responsibility**: `ETLTransformationEngine`

ETL transforms the domain model into a code generation context enriched with Java-specific metadata.

**Transformations**:
- Table → EntityContext (JPA entity class metadata)
- Column → FieldContext (Java field with type mapping)
- Relation → RelationContext (JPA relationship annotations)
- Project → ProjectContext (Maven coordinates, dependencies)

**Type Mappings**:
- `INT` → `Integer`
- `VARCHAR` → `String`
- `DATETIME` → `LocalDateTime`
- `BOOLEAN` → `Boolean`

**Annotation Logic**:
- `primaryKey: true` → `@Id @GeneratedValue`
- `unique: true` → `@Column(unique = true)`
- `nullable: false` → `@Column(nullable = false)`
- Relationships → `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`

### Phase 3: Model-to-Text (M2T) - EGL

**Tool**: Eclipse Epsilon Generation Language (EGL)  
**Input**: `Context` model  
**Output**: Java code files  
**Templates**: `src/main/resources/templates/*.egl`  
**Responsibility**: `EGLTemplateEngine`

EGL templates generate Spring Boot project files from the Context model.

**Generated Files**:
- `Application.java`: Spring Boot main class
- `Entity.java`: JPA entities
- `Repository.java`: Spring Data JPA repositories
- `Service.java`: Business logic layer
- `Controller.java`: REST API controllers
- `JpaAuditingConfig.java`: Auditing configuration
- `application.properties`: Database configuration
- `pom.xml`: Maven build file
- `docker-compose.yml`: Docker containerization
- `Dockerfile`: Container image
- `.dockerignore`: Docker ignore patterns
- `README.md`: Project documentation

---

## Build and Packaging

### Maven Configuration (`pom.xml`)

**Key Dependencies**:
- Eclipse EMF (Ecore, Common, XMI)
- Eclipse Epsilon (Flexmi, ETL, EGL, EOL)
- Spring Boot Starter
- Picocli (CLI framework)
- JUnit 5 (Testing)

**Build Plugins**:
- `maven-compiler-plugin`: Java 17 compilation
- `spring-boot-maven-plugin`: Creates executable JAR with repackage goal
- `maven-shade-plugin`: Alternative fat JAR creation (currently disabled)

**Output**:
- `target/mde-gen.jar`: Executable Spring Boot JAR (21 MB)
- Includes all dependencies (fat JAR)

### Running the JAR

```bash
java -jar target/mde-gen.jar generate examples/healthcare-system.yaml
```

---

## Testing

### Unit Tests

**Location**: `src/test/java/com/mde/`

**Test Suites**:
- `CodeGeneratorTest`: Code generation pipeline tests
- `CodeGeneratorIntegrationTest`: End-to-end integration tests
- `ModelValidationTest`: Validator tests
- `EGLTemplateEngineTest`: Template engine tests
- `ETLTransformationEngineTest`: Transformation tests
- `ContextModelTest`: Context metamodel tests
- `ContextModelIntegrationTest`: Context integration tests

**Run Tests**:
```bash
./mvnw test
```

---

## Code Generation Templates

### Template Structure

All templates are located in `src/main/resources/templates/`:

```
templates/
├── README.egl                    # Project README
├── project/
│   ├── Application.egl           # Spring Boot main class
│   └── pom.egl                   # Maven POM file
├── entity/
│   └── Entity.egl                # JPA Entity classes
├── repository/
│   └── Repository.egl            # Spring Data repositories
├── service/
│   └── Service.egl               # Service layer
├── controller/
│   └── Controller.egl            # REST controllers
├── config/
│   ├── JpaAuditingConfig.egl     # Auditing config
│   └── application.properties.egl # Spring Boot config
└── docker/
    ├── docker-compose.egl        # Docker Compose
    ├── Dockerfile.egl            # Container image
    └── dockerignore.egl          # Docker ignore
```

### Template Syntax (EGL)

EGL is similar to JSP/ERB/EJS:

```java
[% for (entity in ProjectContext.entities) { %]
@Entity
@Table(name = "[%=entity.tableName%]")
public class [%=entity.className%] {
    [% for (field in entity.fields) { %]
    [%=field.annotations%]
    private [%=field.javaType%] [%=field.fieldName%];
    [% } %]
}
[% } %]
```

**Key Features**:
- `[% ... %]`: Code blocks
- `[%= ... %]`: Expression output
- `[%out.print(...)%]`: Explicit output
- Access to full Context model
- Java helper methods available

---

## Extending the Generator

### Adding a New Validator

1. Create class implementing `ModelValidator`:
```java
public class MyCustomValidator implements ModelValidator {
    @Override
    public ValidationResult validate(BackendConfig config) {
        ValidationResult result = new ValidationResult();
        // Add validation logic
        if (someCondition) {
            result.addError("Custom error message");
        }
        return result;
    }
}
```

2. Register in `ModelValidationEngine`:
```java
validators.add(new MyCustomValidator());
```

### Adding a New Template

1. Create `.egl` file in `src/main/resources/templates/`
2. Update `EGLTemplateEngine.generate()` to invoke template
3. Rebuild project: `./mvnw clean package`

### Adding a New Metamodel Attribute

1. Open `model/MDE.ecore` in Eclipse Modeling Tools
2. Add attribute to EClass (e.g., `Column.indexed: boolean`)
3. Regenerate Java code: Right-click GenModel → Generate Model Code
4. Update ETL transformation to populate new attribute
5. Update EGL templates to use new attribute

---

## Troubleshooting

### Common Issues

**Issue**: `Error: mde-gen.jar not found!`  
**Fix**: Run `./mvnw clean package` from project root

**Issue**: `Package registration failed`  
**Fix**: Ensure `ModelDrivenPackage` is registered before loading models

**Issue**: `Template not found: templates/Entity.egl`  
**Fix**: Check that templates exist in `src/main/resources/templates/`

**Issue**: `ETL transformation failed`  
**Fix**: Check `BackendConfigToContext.etl` syntax and model conformance

**Issue**: `Circular reference bug` (infinite JSON loop)  
**Fix**: Already fixed with `@JsonIgnore` on bidirectional relationships

---

## Performance

### Benchmarks

**Test**: Generate healthcare system (6 entities, 28 files)

| Phase | Time | Percentage |
|-------|------|------------|
| T2M (Flexmi) | ~200ms | 15% |
| M2M (ETL) | ~150ms | 12% |
| M2T (EGL) | ~950ms | 73% |
| **Total** | **~1.3s** | **100%** |

**Bottleneck**: EGL template execution (file I/O, string operations)

### Optimization Tips

- Use `--no-color` to reduce ANSI escape sequence processing
- Pre-compile templates (currently loaded on-demand)
- Cache metamodel registrations (currently done)
- Parallelize template execution (future enhancement)

---

## References

- **Eclipse EMF**: https://www.eclipse.org/modeling/emf/
- **Eclipse Epsilon**: https://www.eclipse.org/epsilon/
- **Picocli**: https://picocli.info/
- **Spring Boot**: https://spring.io/projects/spring-boot
- **Model-Driven Engineering**: https://en.wikipedia.org/wiki/Model-driven_engineering

---

## License

This project is open-source. See LICENSE file for details.

---

## Contributors

- Shady Achra (@shady0503)

