[* This template generates a single JPA Entity class *]
package [%= entity.packageName %];

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.io.Serializable;
[* Import Java types based on fields *]
[% var hasLocalDateTime = entity.fields.exists(f | f.javaType = "LocalDateTime"); %]
[% var hasLocalDate = entity.fields.exists(f | f.javaType = "LocalDate"); %]
[% var hasUUID = entity.fields.exists(f | f.javaType = "UUID"); %]
[% var hasBigDecimal = entity.fields.exists(f | f.javaType = "BigDecimal"); %]
[% if (hasLocalDateTime) { %]
import java.time.LocalDateTime;
[% } %]
[% if (hasLocalDate) { %]
import java.time.LocalDate;
[% } %]
[% if (hasUUID) { %]
import java.util.UUID;
[% } %]
[% if (hasBigDecimal) { %]
import java.math.BigDecimal;
[% } %]
[% if (entity.hasRelationships) { %]
import java.util.List;
import java.util.Set;
[% } %]

/**
 * Entity class for [%= entity.tableName %] table
 * Generated by MDE Backend Generator
 */
@Entity
@Table(name = "[%= entity.tableName %]")
@EntityListeners(AuditingEntityListener.class)
@Data
@NoArgsConstructor
@AllArgsConstructor
public class [%= entity.className %] implements Serializable {

    [* Generate Fields *]
    [% for (field in entity.fields) { %]
    [% if (field.isPrimaryKey) { %]
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    [% } %]
    [% if (field.fieldName = "createdAt") { %]
    @CreatedDate
    [% } else if (field.fieldName = "updatedAt") { %]
    @LastModifiedDate
    [% } %]
    @Column(name = "[%= field.columnName %]", nullable = [%= field.isNullable %][% if (field.isUnique) { %], unique = true[% } %])
    private [%= field.javaType %] [%= field.fieldName %];
    
    [% } %]

    [* Generate Relationships *]
    [% for (relation in entity.relations) { %]
    [%  
        // Convert ONE_TO_MANY to OneToMany format
        var relType = relation.relationType;
        var jpaAnnotation = "";
        if (relType = "ONE_TO_ONE") {
            jpaAnnotation = "OneToOne";
        } else if (relType = "ONE_TO_MANY") {
            jpaAnnotation = "OneToMany";
        } else if (relType = "MANY_TO_ONE") {
            jpaAnnotation = "ManyToOne";
        } else if (relType = "MANY_TO_MANY") {
            jpaAnnotation = "ManyToMany";
        } else {
            jpaAnnotation = relType; // fallback
        }
    %]
    @[%= jpaAnnotation %][% if (relation.fetchType.isDefined()) { %](fetch = FetchType.[%= relation.fetchType %][% if (not relation.isOwner and relation.mappedBy.isDefined()) { %], mappedBy = "[%= relation.mappedBy %]"[% } %])[% } else if (not relation.isOwner and relation.mappedBy.isDefined()) { %](mappedBy = "[%= relation.mappedBy %]")[% } %]
    [% if (relation.isOwner and relation.joinColumnName.isDefined()) { %]
    @JoinColumn(name = "[%= relation.joinColumnName %]")
    [% } %]
    [% if (relation.relationType.contains("TO_MANY")) { %]
    private List<[%= relation.targetEntity %]> [%= relation.fieldName %];
    [% } else { %]
    private [%= relation.targetEntity %] [%= relation.fieldName %];
    [% } %]
    
    [% } %]
}
